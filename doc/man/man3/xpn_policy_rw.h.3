.TH "xpn_policy_rw.h" 3 "Wed May 24 2023" "Version Expand version 1.0r5" "Expand" \" -*- nroff -*-
.ad l
.nh
.SH NAME
xpn_policy_rw.h \- Header file to 'TODO'\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'xpn_file\&.h'\fP
.br
\fC#include 'xpn_policy_open\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBXpnGetBlock\fP (int fd, off_t global_offset, off_t *local_offset, int *serv)"
.br
.RI "Calculates the server and the offset\&. "
.ti -1c
.RI "void * \fBXpnReadBlocks\fP (int fd, const void *buffer, size_t size, off_t offset, struct \fBnfi_worker_io\fP ***io_out, int **ion_out, int num_servers)"
.br
.RI "Read blocks\&. "
.ti -1c
.RI "int \fBXpnReadBlocksFinish\fP (int fd, void *buffer, size_t size, off_t offset, struct \fBnfi_worker_io\fP ***io_out, int **ion_out, int num_servers, void *new_buffer)"
.br
.RI "'TODO'\&. "
.ti -1c
.RI "void * \fBXpnWriteBlocks\fP (int fd, const void *buffer, size_t size, off_t offset, struct \fBnfi_worker_io\fP ***io_out, int **ion_out, int num_servers)"
.br
.RI "Write blocks\&. "
.ti -1c
.RI "int \fBXpnWriteBlocksFinish\fP (int fd, const void *buffer, size_t size, off_t offset, struct \fBnfi_worker_io\fP ***io_out, int **ion_out, int num_servers, void *new_buffer)"
.br
.RI "'TODO'\&. "
.ti -1c
.RI "ssize_t \fBXpnReadGetTotalBytes\fP (int fd, ssize_t *res_v, int num_servers)"
.br
.RI "'TODO'\&. "
.ti -1c
.RI "ssize_t \fBXpnWriteGetTotalBytes\fP (int fd, ssize_t *res_v, int num_servers)"
.br
.RI "'TODO'\&. "
.in -1c
.SH "Detailed Description"
.PP 
Header file to 'TODO'\&. 

Header file to 'TODO'\&.
.PP
\fBAuthors\fP
.RS 4
Felix Garcia Carballeira, Diego Camarmas Alonso, Alejandro Calderon Mateos, Luis Miguel Sanchez Garcia, Borja Bergua Guerra 
.RE
.PP
\fBDate\fP
.RS 4
Jul 22, 2021 
.RE
.PP
\fBBug\fP
.RS 4
No known bugs\&. 
.RE
.PP

.PP
Definition in file \fBxpn_policy_rw\&.h\fP\&.
.SH "Function Documentation"
.PP 
.SS "int XpnGetBlock (int fd, off_t global_offset, off_t * local_offset, int * serv)"

.PP
Calculates the server and the offset\&. Calculates the server and the offset in that server of the given offset of a file\&.
.PP
\fBParameters\fP
.RS 4
\fIfd\fP [in] A file descriptor\&. 
.br
\fIglobal_offset\fP [in] The original offset\&. 
.br
\fIlocal_offset\fP [out] The offset in the server\&. 
.br
\fIserv\fP [out] The server in which is located the given offset\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Returns 0 on success or -1 on error\&. 
.RE
.PP

.PP
Definition at line \fB41\fP of file \fBxpn_policy_rw\&.c\fP\&.
.PP
References \fBxpn_filedesc::block_size\fP, \fBpolicy::first_node\fP, \fBPOLICY_RAID0\fP, \fBPOLICY_RAID1\fP, and \fBxpn_file_table\fP\&.
.PP
Referenced by \fBxpn_sread()\fP, \fBxpn_swrite()\fP, \fBXpnReadBlocks()\fP, \fBXpnRWBlocksPolicyBlockByBlock()\fP, and \fBXpnWriteBlocksPolicyRAID1_BlockByBlock()\fP\&.
.SS "void * XpnReadBlocks (int fd, const void * buffer, size_t size, off_t offset, struct \fBnfi_worker_io\fP *** io_out, int ** ion_out, int num_servers)"

.PP
Read blocks\&. Calculates how the blocks have to be read from the servers\&. io_out is an operation matrix\&. io_out[i] (row 'i' in io_out) contains the required operations in server 'i'\&. While ion_out[i] is the number of operations in server 'i' (io_out[i])\&.
.PP
\fBParameters\fP
.RS 4
\fIfd\fP [in] A file descriptor\&. 
.br
\fIbuffer\fP [in] The original buffer\&. 
.br
\fIsize\fP [in] The original size\&. 
.br
\fIoffset\fP [in] The original offset\&. 
.br
\fIio_out\fP [out] The operation matrix\&. 
.br
\fIion_out\fP [out] The length of every row in io_out\&. 
.br
\fInum_servers\fP [in] The number of servers\&.
.RE
.PP
\fBReturns\fP
.RS 4
Returns a pointer to a new buffer on success, or NULL on error\&. 
.RE
.PP

.PP
Definition at line \fB363\fP of file \fBxpn_policy_rw\&.c\fP\&.
.PP
References \fBnfi_worker_io::buffer\fP, \fBnfi_worker_io::offset\fP, \fBPOLICY_RAID0\fP, \fBPOLICY_RAID1\fP, \fBnfi_worker_io::size\fP, \fBxpn_file_table\fP, \fBXpnGetBlock()\fP, \fBXpnReadBlocksPolicyRAID0_AllInOne()\fP, \fBXpnReadBlocksPolicyRAID1_AllInOne()\fP, and \fBXpnRWBlocksPolicyBlockByBlock()\fP\&.
.PP
Referenced by \fBxpn_pread()\fP\&.
.SS "int XpnReadBlocksFinish (int fd, void * buffer, size_t size, off_t offset, struct \fBnfi_worker_io\fP *** io_out, int ** ion_out, int num_servers, void * new_buffer)"

.PP
'TODO'\&. 'TODO'\&.
.PP
\fBParameters\fP
.RS 4
\fIfd\fP 'TODO'\&. 
.br
\fIbuffer\fP 'TODO'\&. 
.br
\fIsize\fP 'TODO'\&. 
.br
\fIoffset\fP 'TODO'\&. 
.br
\fIio_out\fP 'TODO'\&. 
.br
\fIion_out\fP 'TODO'\&. 
.br
\fInum_servers\fP 'TODO'\&. 
.br
\fInew_buffer\fP 'TODO'\&. 
.RE
.PP
\fBReturns\fP
.RS 4
'TODO'\&. 
.RE
.PP

.PP
Definition at line \fB419\fP of file \fBxpn_policy_rw\&.c\fP\&.
.PP
References \fBnfi_worker_io::buffer\fP, \fBnfi_worker_io::offset\fP, \fBPOLICY_RAID0\fP, \fBPOLICY_RAID1\fP, \fBnfi_worker_io::size\fP, \fBxpn_file_table\fP, and \fBXpnReadBlocksPolicyRAID0_AllInOne_Finish()\fP\&.
.PP
Referenced by \fBxpn_pread()\fP\&.
.SS "ssize_t XpnReadGetTotalBytes (int fd, ssize_t * res_v, int num_servers)"

.PP
'TODO'\&. 'TODO'\&.
.PP
\fBParameters\fP
.RS 4
\fIfd\fP 'TODO'\&. 
.br
\fIres_v\fP 'TODO'\&. 
.br
\fInum_servers\fP 'TODO'\&. 
.RE
.PP
\fBReturns\fP
.RS 4
'TODO'\&. 
.RE
.PP

.PP
Definition at line \fB502\fP of file \fBxpn_policy_rw\&.c\fP\&.
.PP
References \fBPOLICY_RAID0\fP, \fBPOLICY_RAID1\fP, and \fBxpn_file_table\fP\&.
.PP
Referenced by \fBxpn_pread()\fP\&.
.SS "void * XpnWriteBlocks (int fd, const void * buffer, size_t size, off_t offset, struct \fBnfi_worker_io\fP *** io_out, int ** ion_out, int num_servers)"

.PP
Write blocks\&. Calculates how the blocks have to be written to the servers\&. io_out is an operation matrix\&. io_out[i] (row 'i' in io_out) contains the required operations in server 'i'\&. While ion_out[i] is the number of operations in server 'i' (io_out[i])\&.
.PP
\fBParameters\fP
.RS 4
\fIfd\fP [in] A file descriptor\&. 
.br
\fIbuffer\fP [in] The original buffer\&. 
.br
\fIsize\fP [in] The original size\&. 
.br
\fIoffset\fP [in] The original offset\&. 
.br
\fIio_out\fP [out] The operation matrix\&. 
.br
\fIion_out\fP [out] The length of every row in io_out\&. 
.br
\fInum_servers\fP [in] The number of servers\&.
.RE
.PP
\fBReturns\fP
.RS 4
Returns 0 on success or -1 on error\&. 
.RE
.PP

.PP
Definition at line \fB441\fP of file \fBxpn_policy_rw\&.c\fP\&.
.PP
References \fBnfi_worker_io::buffer\fP, \fBnfi_worker_io::offset\fP, \fBPOLICY_RAID0\fP, \fBPOLICY_RAID1\fP, \fBnfi_worker_io::size\fP, \fBxpn_file_table\fP, \fBXpnRWBlocksPolicyBlockByBlock()\fP, \fBXpnWriteBlocksPolicyRAID0_AllInOne()\fP, \fBXpnWriteBlocksPolicyRAID1_AllInOne()\fP, and \fBXpnWriteBlocksPolicyRAID1_BlockByBlock()\fP\&.
.PP
Referenced by \fBxpn_pwrite()\fP\&.
.SS "int XpnWriteBlocksFinish (int fd, const void * buffer, size_t size, off_t offset, struct \fBnfi_worker_io\fP *** io_out, int ** ion_out, int num_servers, void * new_buffer)"

.PP
'TODO'\&. 'TODO'\&.
.PP
\fBParameters\fP
.RS 4
\fIfd\fP 'TODO'\&. 
.br
\fIbuffer\fP 'TODO'\&. 
.br
\fIsize\fP 'TODO'\&. 
.br
\fIoffset\fP 'TODO'\&. 
.br
\fIio_out\fP 'TODO'\&. 
.br
\fIion_out\fP 'TODO'\&. 
.br
\fInum_servers\fP 'TODO'\&. 
.br
\fInew_buffer\fP 'TODO'\&. 
.RE
.PP
\fBReturns\fP
.RS 4
'TODO'\&. 
.RE
.PP

.SS "ssize_t XpnWriteGetTotalBytes (int fd, ssize_t * res_v, int num_servers)"

.PP
'TODO'\&. 'TODO'\&.
.PP
\fBParameters\fP
.RS 4
\fIfd\fP 'TODO'\&. 
.br
\fIres_v\fP 'TODO'\&. 
.br
\fInum_servers\fP 'TODO'\&. 
.RE
.PP
\fBReturns\fP
.RS 4
'TODO'\&. 
.RE
.PP

.PP
Definition at line \fB523\fP of file \fBxpn_policy_rw\&.c\fP\&.
.PP
References \fBPOLICY_RAID0\fP, \fBPOLICY_RAID1\fP, and \fBxpn_file_table\fP\&.
.PP
Referenced by \fBxpn_pwrite()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Expand from the source code\&.
