diff -urN fusedav.orig/configure.ac fusedav.new/configure.ac
--- fusedav.orig/configure.ac	2010-05-05 13:57:10.000000000 +0200
+++ fusedav.new/configure.ac	2011-03-21 16:43:19.000000000 +0100
@@ -41,6 +41,7 @@
 AC_PROG_INSTALL
 AC_PROG_LN_S
 AC_PROG_MAKE_SET
+AC_PROG_RANLIB
 
 test_gcc_flag() {
     AC_LANG_CONFTEST([int main() {}])
@@ -109,6 +110,8 @@
 
 AC_CHECK_LIB([pthread], [pthread_create])
 
+AC_CONFIG_SUBDIRS([libneon])
+
 PKG_CHECK_MODULES(NEON, [ neon >= 0.26 ])
 PKG_CHECK_MODULES(FUSE, [ fuse >= 2.5 ])
 
diff -urN fusedav.orig/configure.gnu fusedav.new/configure.gnu
--- fusedav.orig/configure.gnu	1970-01-01 01:00:00.000000000 +0100
+++ fusedav.new/configure.gnu	2011-03-21 16:43:19.000000000 +0100
@@ -0,0 +1 @@
+./configure NEON_CFLAGS="-D_LARGEFILE64_SOURCE -DNE_LFS -I../libneon/src" NEON_LIBS="-L../libneon/src/.libs -lneon" LIBS="-lexpat -lgssapi_krb5 -lssl"
diff -urN fusedav.orig/libneon/configure.gnu fusedav.new/libneon/configure.gnu
--- fusedav.orig/libneon/configure.gnu	1970-01-01 01:00:00.000000000 +0100
+++ fusedav.new/libneon/configure.gnu	2011-03-21 16:43:19.000000000 +0100
@@ -0,0 +1 @@
+unset NEON_CFLAGS; unset NEON_LIBS; ./configure --enable-threadsafe-ssl=posix --with-ssl=openssl --disable-shared ; cp `which libtool` libtool
diff -urN fusedav.orig/Makefile.am fusedav.new/Makefile.am
--- fusedav.orig/Makefile.am	2010-05-05 13:57:10.000000000 +0200
+++ fusedav.new/Makefile.am	2011-03-21 16:43:19.000000000 +0100
@@ -17,7 +17,7 @@
 # Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 
 EXTRA_DIST=bootstrap.sh README LICENSE
-SUBDIRS=src doc
+SUBDIRS=libneon src doc
 
 MAINTAINERCLEANFILES = README
 noinst_DATA = README LICENSE
diff -urN fusedav.orig/src/filecache.c fusedav.new/src/filecache.c
--- fusedav.orig/src/filecache.c	2011-03-21 16:41:58.000000000 +0100
+++ fusedav.new/src/filecache.c	2011-03-21 16:43:19.000000000 +0100
@@ -65,19 +65,19 @@
     struct file_info *next;
 };
 
-static struct file_info *files = NULL;
-static pthread_mutex_t files_mutex = PTHREAD_MUTEX_INITIALIZER;
+/*static struct file_info *files = NULL;
+static pthread_mutex_t files_mutex = PTHREAD_MUTEX_INITIALIZER;*/
 
-static int file_cache_sync_unlocked(struct file_info *fi);
+static int file_cache_sync_unlocked(struct session_info *sess, struct file_info *fi);
 
 extern int no_cache;
 
-void* file_cache_get(const char *path) {
+void* file_cache_get(struct session_info *sess, const char *path) {
     struct file_info *f, *r = NULL;
 
-    pthread_mutex_lock(&files_mutex);
+    pthread_mutex_lock(&sess->files_mutex);
     
-    for (f = files; f; f = f->next) {
+    for (f = sess->files; f; f = f->next) {
         
         pthread_mutex_lock(&f->mutex);
         if (!f->dead && f->filename && !strcmp(path, f->filename)) {
@@ -90,7 +90,7 @@
             break;
     }
     
-    pthread_mutex_unlock(&files_mutex);
+    pthread_mutex_unlock(&sess->files_mutex);
     return f;
 }
 
@@ -106,7 +106,7 @@
     free(fi);
 }
 
-void file_cache_unref(void *f) {
+void file_cache_unref(struct session_info *sess, void *f) {
     struct file_info *fi = f;
     assert(fi);
 
@@ -117,25 +117,25 @@
 
     if (!fi->ref && fi->dead) {
         if (!no_cache)
-            file_cache_sync_unlocked(fi);
+            file_cache_sync_unlocked(sess, fi);
         file_cache_free_unlocked(fi);
     }
 
     pthread_mutex_unlock(&fi->mutex);
 }
 
-static void file_cache_unlink(struct file_info *fi) {
+static void file_cache_unlink(struct session_info *sess, struct file_info *fi) {
     struct file_info *s, *prev;
     assert(fi);
 
-    pthread_mutex_lock(&files_mutex);
+    pthread_mutex_lock(&sess->files_mutex);
     
-    for (s = files, prev = NULL; s; s = s->next) {
+    for (s = sess->files, prev = NULL; s; s = s->next) {
         if (s == fi) {
             if (prev)
                 prev->next = s->next;
             else
-                files = s->next;
+                sess->files = s->next;
 
             break;
         }
@@ -143,15 +143,15 @@
         prev = s;
     }
     
-    pthread_mutex_unlock(&files_mutex);
+    pthread_mutex_unlock(&sess->files_mutex);
 }
 
-int file_cache_close(void *f) {
+int file_cache_close(struct session_info *sess, void *f) {
     struct file_info *fi = f;
     int r = 0;
     assert(fi);
 
-    file_cache_unlink(f);
+    file_cache_unlink(sess, f);
 
     pthread_mutex_lock(&fi->mutex);
     fi->dead = 1;
@@ -160,19 +160,19 @@
     return r;
 }
 
-void* file_cache_open(const char *path, int flags) {
+void* file_cache_open(struct session_info *sess, const char *path, int flags) {
     struct file_info *fi = NULL;
     char tempfile[PATH_MAX];
     const char *length = NULL;
     ne_request *req = NULL;
     ne_session *session;
 
-    if (!(session = session_get(1))) {
+    if (!(session = session_get(sess, 1))) {
         errno = EIO;
         goto fail;
     }
 
-    if ((fi = file_cache_get(path))) {
+    if ((fi = file_cache_get(sess, path))) {
         if (flags & O_RDONLY || flags & O_RDWR) fi->readable = 1;
         if (flags & O_WRONLY || flags & O_RDWR) fi->writable = 1;
         return fi;
@@ -213,10 +213,10 @@
 
     pthread_mutex_init(&fi->mutex, NULL);
     
-    pthread_mutex_lock(&files_mutex);
-    fi->next = files;
-    files = fi;
-    pthread_mutex_unlock(&files_mutex);
+    pthread_mutex_lock(&sess->files_mutex);
+    fi->next = sess->files;
+    sess->files = fi;
+    pthread_mutex_unlock(&sess->files_mutex);
 
     fi->ref = 1;
     
@@ -237,14 +237,14 @@
     return NULL;
 }
 
-static int load_up_to_unlocked(struct file_info *fi, off_t l) {
+static int load_up_to_unlocked(struct session_info *sess, struct file_info *fi, off_t l) {
 
     ne_content_range range;
     ne_session *session;
 
     assert(fi && (fi->fd >= 0));
 
-    if (!(session = session_get(1))) {
+    if (!(session = session_get(sess, 1))) {
         errno = EIO;
         return -1;
     }
@@ -272,7 +272,7 @@
     return 0;
 }
 
-int file_cache_read(void *f, char *buf, size_t size, off_t offset) {
+int file_cache_read(struct session_info *sess, void *f, char *buf, size_t size, off_t offset) {
     struct file_info *fi = f;
     ssize_t r = -1;
     
@@ -280,7 +280,7 @@
 
     pthread_mutex_lock(&fi->mutex);
 
-    if (load_up_to_unlocked(fi, offset+size) < 0)
+    if (load_up_to_unlocked(sess, fi, offset+size) < 0)
         goto finish;
 
     if ((r = pread(fi->fd, buf, size, offset)) < 0)
@@ -293,7 +293,7 @@
     return r;
 }
 
-int file_cache_write(void *f, const char *buf, size_t size, off_t offset) {
+int file_cache_write(struct session_info *sess, void *f, const char *buf, size_t size, off_t offset) {
     struct file_info *fi = f;
     ssize_t r = -1;
 
@@ -306,7 +306,7 @@
         goto finish;
     }
 
-    if (load_up_to_unlocked(fi, offset) < 0)
+    if (load_up_to_unlocked(sess, fi, offset) < 0)
         goto finish;
         
     if ((r = pwrite(fi->fd, buf, size, offset)) < 0)
@@ -342,7 +342,7 @@
     return r;
 }
 
-int file_cache_sync_unlocked(struct file_info *fi) {
+int file_cache_sync_unlocked(struct session_info *sess, struct file_info *fi) {
     int r = -1;
     ne_session *session;
 
@@ -358,13 +358,13 @@
         goto finish;
     }
     
-    if (load_up_to_unlocked(fi, (off_t) -1) < 0)
+    if (load_up_to_unlocked(sess, fi, (off_t) -1) < 0)
         goto finish;
 
     if (lseek(fi->fd, 0, SEEK_SET) == (off_t)-1)
         goto finish;
 
-    if (!(session = session_get(1))) {
+    if (!(session = session_get(sess, 1))) {
         errno = EIO;
         goto finish;
     }
@@ -375,8 +375,8 @@
         goto finish;
     }
 
-    stat_cache_invalidate(fi->filename);
-    dir_cache_invalidate_parent(fi->filename);
+    stat_cache_invalidate(sess, fi->filename);
+    dir_cache_invalidate_parent(sess, fi->filename);
 
     r = 0;
 
@@ -385,37 +385,37 @@
     return r;
 }
 
-int file_cache_sync(void *f) {
+int file_cache_sync(struct session_info *sess, void *f) {
     struct file_info *fi = f;
     int r = -1;
     assert(fi);
 
     pthread_mutex_lock(&fi->mutex);
-    r = file_cache_sync_unlocked(fi);
+    r = file_cache_sync_unlocked(sess, fi);
     pthread_mutex_unlock(&fi->mutex);
     
     return r;
 }
 
-int file_cache_close_all(void) {
+int file_cache_close_all(struct session_info *sess) {
     int r = 0;
 
-    pthread_mutex_lock(&files_mutex);
+    pthread_mutex_lock(&sess->files_mutex);
 
-    while (files) {
-        struct file_info *fi = files;
+    while (sess->files) {
+        struct file_info *fi = sess->files;
         
         pthread_mutex_lock(&fi->mutex);
         fi->ref++;
         pthread_mutex_unlock(&fi->mutex);
 
-        pthread_mutex_unlock(&files_mutex);
-        file_cache_close(fi);
-        file_cache_unref(fi);
-        pthread_mutex_lock(&files_mutex);
+        pthread_mutex_unlock(&sess->files_mutex);
+        file_cache_close(sess, fi);
+        file_cache_unref(sess, fi);
+        pthread_mutex_lock(&sess->files_mutex);
     }
 
-    pthread_mutex_unlock(&files_mutex);
+    pthread_mutex_unlock(&sess->files_mutex);
 
     return r;
 }
diff -urN fusedav.orig/src/filecache.h fusedav.new/src/filecache.h
--- fusedav.orig/src/filecache.h	2010-05-05 13:57:10.000000000 +0200
+++ fusedav.new/src/filecache.h	2011-03-21 16:43:19.000000000 +0100
@@ -25,17 +25,19 @@
 
 #include <ne_session.h>
 
-void* file_cache_open(const char *path, int flags);
-void* file_cache_get(const char *path);
-void file_cache_unref(void *f);
+#include "session.h"
 
-int file_cache_close(void *f);
+void* file_cache_open(struct session_info *sess, const char *path, int flags);
+void* file_cache_get(struct session_info *sess, const char *path);
+void file_cache_unref(struct session_info *sess, void *f);
 
-int file_cache_read(void *f, char *buf, size_t size, off_t offset);
-int file_cache_write(void *f, const char *buf, size_t size, off_t offset);
+int file_cache_close(struct session_info *sess, void *f);
+
+int file_cache_read(struct session_info *sess, void *f, char *buf, size_t size, off_t offset);
+int file_cache_write(struct session_info *sess, void *f, const char *buf, size_t size, off_t offset);
 int file_cache_truncate(void *f, off_t s);
-int file_cache_sync(void *f);
-int file_cache_close_all(void);
+int file_cache_sync(struct session_info *sess, void *f);
+int file_cache_close_all(struct session_info *sess);
 
 off_t file_cache_get_size(void *f);
 
diff -urN fusedav.orig/src/fusedav.c fusedav.new/src/fusedav.c
--- fusedav.orig/src/fusedav.c	2011-03-21 16:41:58.000000000 +0100
+++ fusedav.new/src/fusedav.c	2011-03-21 16:54:45.000000000 +0100
@@ -65,12 +65,13 @@
 };
 
 mode_t mask = 0;
-int debug = 0;
+int dav_debug = 0;
 struct fuse* fuse = NULL;
 ne_lock_store *lock_store = NULL;
 struct ne_lock *lock = NULL;
 int lock_thread_exit = 0;
 int lock_timeout = 60;
+
 int no_cache = 0;
 
 #define MIME_XATTR "user.mime_type"
@@ -83,7 +84,17 @@
     const char *root;
 };
 
-static int get_stat(const char *path, struct stat *stbuf);
+struct getdir_propfind_callback_userdata {
+    struct session_info *sess;
+    struct fill_info *f;
+};
+
+struct getattr_propfind_callback_userdata {
+    struct session_info *sess;
+    struct stat *st;
+};
+
+static int get_stat(struct session_info *sess, const char *path, struct stat *stbuf);
 
 static pthread_once_t path_cvt_once = PTHREAD_ONCE_INIT;
 static pthread_key_t path_cvt_tsd_key;
@@ -92,7 +103,7 @@
     pthread_key_create(&path_cvt_tsd_key, free);
 }
 
-static const char *path_cvt(const char *path) {
+static const char *path_cvt(const char *path, struct session_info *sess) {
     char *r, *t;
     int l;
 
@@ -101,9 +112,9 @@
     if ((r = pthread_getspecific(path_cvt_tsd_key)))
         free(r);
 
-    t = malloc((l = strlen(base_directory)+strlen(path))+1);
+    t = malloc((l = strlen(sess->base_directory)+strlen(path))+1);
     assert(t);
-    sprintf(t, "%s%s", base_directory, path);
+    sprintf(t, "%s%s", sess->base_directory, path);
 
     if (l > 1 && t[l-1] == '/')
         t[l-1] = 0;
@@ -117,6 +128,7 @@
 }
 
 static int simple_propfind_with_redirect(
+        struct session_info *sess,
         ne_session *session,
         const char *path,
         int depth,
@@ -135,10 +147,40 @@
         if (!(u = ne_redirect_location(session)))
             break;
 
-        if (!session_is_local(u))
+        if (!session_is_local(sess, u))
+            break;
+
+        if (dav_debug)
+            fprintf(stderr, "REDIRECT FROM '%s' to '%s'\n", path, u->path);
+        
+        path = u->path;
+    }
+
+    return ret;
+}
+
+static int getmodtime_and_length_with_redirect(
+        struct session_info *sess,
+        ne_session *session,
+        const char *path,
+        char **length,
+        char **modtime) {
+
+    int i, ret;
+    
+    for (i = 0; i < MAX_REDIRECTS; i++) {
+        const ne_uri *u;
+
+        if ((ret = ne_getmodtime_and_length(session, path, length, modtime)) != NE_REDIRECT)
+            return ret;
+
+        if (!(u = ne_redirect_location(session)))
+            break;
+
+        if (!session_is_local(sess, u))
             break;
 
-        if (debug)
+        if (dav_debug)
             fprintf(stderr, "REDIRECT FROM '%s' to '%s'\n", path, u->path);
         
         path = u->path;
@@ -148,6 +190,7 @@
 }
 
 static int proppatch_with_redirect(
+        struct session_info *sess,
         ne_session *session,
         const char *path,
         const ne_proppatch_operation *ops) {
@@ -163,10 +206,10 @@
         if (!(u = ne_redirect_location(session)))
             break;
 
-        if (!session_is_local(u))
+        if (!session_is_local(sess, u))
             break;
 
-        if (debug)
+        if (dav_debug)
             fprintf(stderr, "REDIRECT FROM '%s' to '%s'\n", path, u->path);
         
         path = u->path;
@@ -217,6 +260,35 @@
     st->st_gid = getgid();
 }
 
+static void fill_stat_modtime_and_length(struct stat* st, int is_dir, const char *gcl, const char *glm, const char *cd) {
+        
+    assert(st);
+
+    memset(st, 0, sizeof(struct stat));
+    
+    if (is_dir) {
+        st->st_mode = S_IFDIR | 0777;
+        st->st_nlink = 3;            /* find will ignore this directory if nlin <= and st_size == 0 */
+        st->st_size = 4096;
+    } else {
+        st->st_mode = S_IFREG | 0666;
+        st->st_nlink = 1;
+        st->st_size = gcl ? atoll(gcl) : 0;
+    }
+
+    st->st_atime = time(NULL);
+    st->st_mtime = glm ? ne_rfc1123_parse(glm) : 0;
+    st->st_ctime = cd ? ne_iso8601_parse(cd) : 0;
+    
+    st->st_blocks = (st->st_size+511)/512;
+    /*fprintf(stderr, "a: %u; m: %u; c: %u\n", st->st_atime, st->st_mtime, st->st_ctime);*/
+
+    st->st_mode &= ~mask;
+    
+    st->st_uid = getuid();
+    st->st_gid = getgid();
+}
+
 static char *strip_trailing_slash(char *fn, int *is_dir) {
     size_t l = strlen(fn);
     assert(fn);
@@ -230,7 +302,8 @@
 }
 
 static void getdir_propfind_callback(void *userdata, const ne_uri *u, const ne_prop_result_set *results) {
-    struct fill_info *f = userdata;
+    struct session_info *sess = ((struct getdir_propfind_callback_userdata *)userdata)->sess;
+    struct fill_info *f = ((struct getdir_propfind_callback_userdata *)userdata)->f;
     struct stat st;
     char fn[PATH_MAX], *t;
     int is_dir = 0;
@@ -249,13 +322,13 @@
         else
             t = fn;
 
-        dir_cache_add(f->root, t);
+        dir_cache_add(sess, f->root, t);
         f->filler(f->buf, h = ne_path_unescape(t), NULL, 0);
         free(h);
     }
 
     fill_stat(&st, results, is_dir);
-    stat_cache_set(fn, &st);
+    stat_cache_set(sess, fn, &st);
 }
 
 static void getdir_cache_callback(
@@ -275,7 +348,8 @@
     free(h);
 }
 
-static int dav_readdir(
+int dav_readdir(
+        struct session_info *sess,
         const char *path,
         void *buf,
         fuse_fill_dir_t filler,
@@ -283,11 +357,12 @@
         __unused struct fuse_file_info *fi) {
     
     struct fill_info f;
+    struct getdir_propfind_callback_userdata u;
     ne_session *session;
 
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "getdir(%s)\n", path);
 
     f.buf = buf;
@@ -297,30 +372,33 @@
     filler(buf, ".", NULL, 0);
     filler(buf, "..", NULL, 0);
     
-    if (dir_cache_enumerate(path, getdir_cache_callback, &f) < 0) {
+    if (dir_cache_enumerate(sess, path, getdir_cache_callback, &f) < 0) {
 
-        if (debug)
+        if (dav_debug)
             fprintf(stderr, "DIR-CACHE-MISS\n");
         
-        if (!(session = session_get(1))) 
+        if (!(session = session_get(sess, 1))) 
             return -EIO;
 
-        dir_cache_begin(path);
+        dir_cache_begin(sess, path);
         
-        if (simple_propfind_with_redirect(session, path, NE_DEPTH_ONE, query_properties, getdir_propfind_callback, &f) != NE_OK) {
-            dir_cache_finish(path, 2);
-            fprintf(stderr, "PROPFIND failed: %s\n", ne_get_error(session));
+        u.sess = sess;
+        u.f = &f;
+        if (simple_propfind_with_redirect(sess, session, path, NE_DEPTH_ONE, query_properties, getdir_propfind_callback, &u) != NE_OK) {
+            dir_cache_finish(sess, path, 2);
+            fprintf(stderr, "dav_readdir: PROPFIND failed: %s\n", ne_get_error(session));
             return -ENOENT;
         }
 
-        dir_cache_finish(path, 1);
+        dir_cache_finish(sess, path, 1);
     }
 
     return 0;
 }
 
 static void getattr_propfind_callback(void *userdata, const ne_uri *u, const ne_prop_result_set *results) {
-    struct stat *st = (struct stat*) userdata;
+    struct session_info *sess = ((struct getattr_propfind_callback_userdata *)userdata)->sess;
+    struct stat *st = ((struct getattr_propfind_callback_userdata *)userdata)->st;
     char fn[PATH_MAX];
     int is_dir;
 
@@ -331,52 +409,105 @@
     strip_trailing_slash(fn, &is_dir);
     
     fill_stat(st, results, is_dir);
-    stat_cache_set(fn, st);
+    stat_cache_set(sess, fn, st);
+}
+
+static int get_stat(struct session_info *sess, const char *path, struct stat *stbuf) {
+    ne_session *session;
+    struct getattr_propfind_callback_userdata u;
+
+    if (!(session = session_get(sess, 1))) 
+        return -EIO;
+
+    if (stat_cache_get(sess, path, stbuf) == 0) {
+        return stbuf->st_mode == 0 ? -ENOENT : 0;
+    } else {
+        if (dav_debug)
+            fprintf(stderr, "STAT-CACHE-MISS\n");
+
+        u.sess = sess;
+        u.st = stbuf;
+        if (simple_propfind_with_redirect(sess, session, path, NE_DEPTH_ZERO, query_properties, getattr_propfind_callback, &u) != NE_OK) {
+            stat_cache_invalidate(sess, path);
+            //fprintf(stderr, "get_stat: PROPFIND failed: %s\n", ne_get_error(session));
+            return -ENOENT;
+        }
+
+        return 0;
+    }
 }
 
-static int get_stat(const char *path, struct stat *stbuf) {
+static int get_stat_with_head(struct session_info *sess, const char *path, struct stat *stbuf) {
     ne_session *session;
+    struct getattr_propfind_callback_userdata u;
+    char *length, *modtime;
+    
+    length = modtime = NULL;
 
-    if (!(session = session_get(1))) 
+    if (!(session = session_get(sess, 1))) 
         return -EIO;
 
-    if (stat_cache_get(path, stbuf) == 0) {
+    if (stat_cache_get(sess, path, stbuf) == 0) {
         return stbuf->st_mode == 0 ? -ENOENT : 0;
     } else {
-        if (debug)
+        if (dav_debug)
             fprintf(stderr, "STAT-CACHE-MISS\n");
 
-        if (simple_propfind_with_redirect(session, path, NE_DEPTH_ZERO, query_properties, getattr_propfind_callback, stbuf) != NE_OK) {
-            stat_cache_invalidate(path);
-            fprintf(stderr, "PROPFIND failed: %s\n", ne_get_error(session));
+        u.sess = sess;
+        u.st = stbuf;
+        if (getmodtime_and_length_with_redirect(sess, session, path, &length, &modtime) != NE_OK) {
+            stat_cache_invalidate(sess, path);
+            //fprintf(stderr, "get_stat: PROPFIND failed: %s\n", ne_get_error(session));
             return -ENOENT;
         }
+        else {
+		char fn[PATH_MAX];
+		int is_dir;
+
+		assert(stbuf);
+
+		strncpy(fn, path, sizeof(fn));
+		fn[sizeof(fn)-1] = 0;
+		strip_trailing_slash(fn, &is_dir);
+		
+		fill_stat_modtime_and_length(stbuf, is_dir, length, modtime, NULL);
+		stat_cache_set(sess, fn, stbuf);
+        }
 
         return 0;
     }
 }
 
-static int dav_getattr(const char *path, struct stat *stbuf) {
-    path = path_cvt(path);
-    if (debug)
+int dav_getattr(struct session_info *sess, const char *path, struct stat *stbuf) {
+    int ret;
+    
+    //path = path_cvt(path, sess); // We don't want to remove the trailing '/' in dirs
+
+    if (dav_debug)
         fprintf(stderr, "getattr(%s)\n", path);
-    return get_stat(path, stbuf);
+
+    ret = get_stat(sess, path, stbuf);
+
+    if (ret < 0)
+        ret = get_stat_with_head(sess, path, stbuf); // If get_stat() fails, let's try using HEAD
+    
+    return ret;
 }
 
-static int dav_unlink(const char *path) {
+int dav_unlink(struct session_info *sess, const char *path) {
     int r;
     struct stat st;
     ne_session *session;
 
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "unlink(%s)\n", path);
 
-    if (!(session = session_get(1))) 
+    if (!(session = session_get(sess, 1))) 
         return -EIO;
 
-    if ((r = get_stat(path, &st)) < 0)
+    if ((r = get_stat(sess, path, &st)) < 0)
         return r;
 
     if (!S_ISREG(st.st_mode))
@@ -387,27 +518,27 @@
         return -ENOENT;
     }
 
-    stat_cache_invalidate(path);
-    dir_cache_invalidate_parent(path);
+    stat_cache_invalidate(sess, path);
+    dir_cache_invalidate_parent(sess, path);
     
     return 0;
 }
 
-static int dav_rmdir(const char *path) {
+int dav_rmdir(struct session_info *sess, const char *path) {
     char fn[PATH_MAX];
     int r;
     struct stat st;
     ne_session *session;
 
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "rmdir(%s)\n", path);
 
-    if (!(session = session_get(1))) 
+    if (!(session = session_get(sess, 1))) 
         return -EIO;
 
-    if ((r = get_stat(path, &st)) < 0)
+    if ((r = get_stat(sess, path, &st)) < 0)
         return r;
 
     if (!S_ISDIR(st.st_mode))
@@ -420,22 +551,22 @@
         return -ENOENT;
     }
 
-    stat_cache_invalidate(path);
-    dir_cache_invalidate_parent(path);
+    stat_cache_invalidate(sess, path);
+    dir_cache_invalidate_parent(sess, path);
 
     return 0;
 }
 
-static int dav_mkdir(const char *path, __unused mode_t mode) {
+int dav_mkdir(struct session_info *sess, const char *path, __unused mode_t mode) {
     char fn[PATH_MAX];
     ne_session *session;
 
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "mkdir(%s)\n", path);
 
-    if (!(session = session_get(1))) 
+    if (!(session = session_get(sess, 1))) 
         return -EIO;
 
     snprintf(fn, sizeof(fn), "%s/", path);
@@ -445,31 +576,31 @@
         return -ENOENT;
     }
 
-    stat_cache_invalidate(path);
-    dir_cache_invalidate_parent(path);
+    stat_cache_invalidate(sess, path);
+    dir_cache_invalidate_parent(sess, path);
     
     return 0;
 }
 
-static int dav_rename(const char *from, const char *to) {
+int dav_rename(struct session_info *sess, const char *from, const char *to) {
     ne_session *session;
     int r = 0;
     struct stat st;
     char fn[PATH_MAX], *_from;
 
-    from = _from = strdup(path_cvt(from));
+    from = _from = strdup(path_cvt(from, sess));
     assert(from);
-    to = path_cvt(to);
+    to = path_cvt(to, sess);
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "rename(%s, %s)\n", from, to);
 
-    if (!(session = session_get(1))) {
+    if (!(session = session_get(sess, 1))) {
         r = -EIO;
         goto finish;
     }
 
-    if ((r = get_stat(from, &st)) < 0)
+    if ((r = get_stat(sess, from, &st)) < 0)
         goto finish;
 
     if (S_ISDIR(st.st_mode)) {
@@ -483,11 +614,11 @@
         goto finish;
     }
     
-    stat_cache_invalidate(from);
-    stat_cache_invalidate(to);
+    stat_cache_invalidate(sess, from);
+    stat_cache_invalidate(sess, to);
 
-    dir_cache_invalidate_parent(from);
-    dir_cache_invalidate_parent(to);
+    dir_cache_invalidate_parent(sess, from);
+    dir_cache_invalidate_parent(sess, to);
 
 finish:
 
@@ -496,60 +627,60 @@
     return r;
 }
 
-static int dav_release(const char *path, __unused struct fuse_file_info *info) {
+int dav_release(struct session_info *sess, const char *path, __unused struct fuse_file_info *info) {
     void *f = NULL;
     int r = 0;
     ne_session *session;
 
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "release(%s)\n", path);
 
-    if (!(session = session_get(1))) {
+    if (!(session = session_get(sess, 1))) {
         r = -EIO;
         goto finish;
     }
     
-    if (!(f = file_cache_get(path))) {
-        fprintf(stderr, "release() called for closed file\n");
+    if (!(f = file_cache_get(sess, path))) {
+        //fprintf(stderr, "release() called for closed file\n");
         r = -EFAULT;
         goto finish;
     }
 
-    if (file_cache_close(f) < 0) {
+    if (file_cache_close(sess, f) < 0) {
         r = -errno;
         goto finish;
     }
 
 finish:
     if (f)
-        file_cache_unref(f);
+        file_cache_unref(sess, f);
     
     return r;
 }
 
-static int dav_fsync(const char *path, __unused int isdatasync, __unused struct fuse_file_info *info) {
+int dav_fsync(struct session_info *sess, const char *path, __unused int isdatasync, __unused struct fuse_file_info *info) {
     void *f = NULL;
     int r = 0;
     ne_session *session;
 
-    path = path_cvt(path);
-    if (debug)
+    path = path_cvt(path, sess);
+    if (dav_debug)
         fprintf(stderr, "fsync(%s)\n", path);
 
-    if (!(session = session_get(1))) {
+    if (!(session = session_get(sess, 1))) {
         r = -EIO;
         goto finish;
     }
 
-    if (!(f = file_cache_get(path))) {
+    if (!(f = file_cache_get(sess, path))) {
         fprintf(stderr, "fsync() called for closed file\n");
         r = -EFAULT;
         goto finish;
     }
 
-    if ((!no_cache) && (file_cache_sync(f) < 0)) {
+    if ((!no_cache) && (file_cache_sync(sess, f) < 0)) {
         r = -errno;
         goto finish;
     }
@@ -557,21 +688,21 @@
 finish:
     
     if (f)
-        file_cache_unref(f);
+        file_cache_unref(sess, f);
 
     return r;
 }
 
-static int dav_mknod(const char *path, mode_t mode, __unused dev_t rdev) {
+int dav_mknod(struct session_info *sess, const char *path, mode_t mode, __unused dev_t rdev) {
     char tempfile[PATH_MAX];
     int fd;
     ne_session *session;
 
-    path = path_cvt(path);
-    if (debug)
+    path = path_cvt(path, sess);
+    if (dav_debug)
         fprintf(stderr, "mknod(%s)\n", path);
 
-    if (!(session = session_get(1))) 
+    if (!(session = session_get(sess, 1))) 
         return -EIO;
 
     if (!S_ISREG(mode))
@@ -591,50 +722,50 @@
 
     close(fd);
 
-    stat_cache_invalidate(path);
-    dir_cache_invalidate_parent(path);
+    stat_cache_invalidate(sess, path);
+    dir_cache_invalidate_parent(sess, path);
 
     return 0;
 }
 
-static int dav_open(const char *path, struct fuse_file_info *info) {
+int dav_open(struct session_info *sess, const char *path, struct fuse_file_info *info) {
     void *f;
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "open(%s)\n", path);
 
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
 
-    if (!(f = file_cache_open(path, info->flags)))
+    if (!(f = file_cache_open(sess, path, info->flags)))
         return -errno;
 
-    file_cache_unref(f);
+    file_cache_unref(sess, f);
 
     return 0;
 }
 
-static int dav_read(const char *path, char *buf, size_t size, off_t offset, __unused struct fuse_file_info *info) {
+int dav_read(struct session_info *sess, const char *path, char *buf, size_t size, off_t offset, __unused struct fuse_file_info *info) {
     void *f = NULL;
     ssize_t r;
  
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
     
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "read(%s, %lu+%lu)\n", path, (unsigned long) offset, (unsigned long) size);
     
-    if (!(f = file_cache_get(path))) {
+    if (!(f = file_cache_get(sess, path))) {
         fprintf(stderr, "read() called for closed file\n");
         r = -EFAULT;
         goto finish;
     }
 
     if (no_cache) {
-        if ((r = remote_access_read(f, buf, size, offset)) < 0) {
+        if ((r = remote_access_read(sess, f, buf, size, offset)) < 0) {
             r = -errno;
             goto finish;
         }
     } else {
-        if ((r = file_cache_read(f, buf, size, offset)) < 0) {
+        if ((r = file_cache_read(sess, f, buf, size, offset)) < 0) {
             r = -errno;
             goto finish;
         }
@@ -642,33 +773,33 @@
 
 finish:
     if (f)
-        file_cache_unref(f);
+        file_cache_unref(sess, f);
 
     return r;
 }
 
-static int dav_write(const char *path, const char *buf, size_t size, off_t offset, __unused struct fuse_file_info *info) {
+int dav_write(struct session_info *sess, const char *path, const char *buf, size_t size, off_t offset, __unused struct fuse_file_info *info) {
     void *f = NULL;
     ssize_t r;
 
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "write(%s, %lu+%lu)\n", path, (unsigned long) offset, (unsigned long) size);
 
-    if (!(f = file_cache_get(path))) {
+    if (!(f = file_cache_get(sess, path))) {
         fprintf(stderr, "write() called for closed file\n");
         r = -EFAULT;
         goto finish;
     }
 
     if (no_cache) {
-        if ((r = remote_access_write(f, buf, size, offset)) < 0) {
+        if ((r = remote_access_write(sess, f, buf, size, offset)) < 0) {
             r = -errno;
             goto finish;
         }
     } else {
-        if ((r = file_cache_write(f, buf, size, offset)) < 0) {
+        if ((r = file_cache_write(sess, f, buf, size, offset)) < 0) {
             r = -errno;
             goto finish;
         }
@@ -676,27 +807,27 @@
 
 finish:
     if (f)
-        file_cache_unref(f);
+        file_cache_unref(sess, f);
 
     return r;
 }
 
 
-static int dav_truncate(const char *path, off_t size) {
+int dav_truncate(struct session_info *sess, const char *path, off_t size) {
     void *f = NULL;
     int r = 0;
     ne_session *session;
     
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
     
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "truncate(%s, %lu)\n", path, (unsigned long) size);
 
-    if (!(session = session_get(1)))
+    if (!(session = session_get(sess, 1)))
         r = -EIO;
         goto finish;
     
-    if (!(f = file_cache_get(path))) {
+    if (!(f = file_cache_get(sess, path))) {
         fprintf(stderr, "truncate() called for closed file\n");
         r = -EFAULT;
         goto finish;
@@ -709,12 +840,12 @@
 
 finish:
     if (f)
-        file_cache_unref(f);
+        file_cache_unref(sess, f);
     
     return r;
 }
 
-static int dav_utime(const char *path, struct utimbuf *buf) {
+int dav_utime(struct session_info *sess, const char *path, struct utimbuf *buf) {
     ne_session *session;
     const ne_propname getlastmodified = { "DAV:", "getlastmodified" };
     ne_proppatch_operation ops[2];
@@ -724,9 +855,9 @@
     assert(path);
     assert(buf);
 
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
     
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "utime(%s, %lu, %lu)\n", path, (unsigned long) buf->actime, (unsigned long) buf->modtime);
     
     ops[0].name = &getlastmodified;
@@ -734,18 +865,18 @@
     ops[0].value = date = ne_rfc1123_date(buf->modtime);
     ops[1].name = NULL;
 
-    if (!(session = session_get(1))) {
+    if (!(session = session_get(sess, 1))) {
         r = -EIO;
         goto finish;
     }
 
-    if (proppatch_with_redirect(session, path, ops)) {
+    if (proppatch_with_redirect(sess, session, path, ops)) {
         fprintf(stderr, "PROPPATCH failed: %s\n", ne_get_error(session));
         r = -ENOTSUP;
         goto finish;
     }
     
-    stat_cache_invalidate(path);
+    stat_cache_invalidate(sess, path);
 
 finish:
     free(date);
@@ -811,7 +942,8 @@
     ne_propset_iterate(results, listxattr_iterator, l);
 }
 
-static int dav_listxattr(
+int dav_listxattr(
+        struct session_info *sess,
         const char *path,
         char *list,
         size_t size) {
@@ -822,9 +954,9 @@
 
     assert(path);
 
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "listxattr(%s, .., %lu)\n", path, (unsigned long) size);
 
     if (list) {
@@ -845,11 +977,11 @@
         l.size = sizeof(MIME_XATTR);
     }
     
-    if (!(session = session_get(1))) 
+    if (!(session = session_get(sess, 1))) 
         return -EIO;
 
-    if (simple_propfind_with_redirect(session, path, NE_DEPTH_ZERO, NULL, listxattr_propfind_callback, &l) != NE_OK) {
-        fprintf(stderr, "PROPFIND failed: %s\n", ne_get_error(session));
+    if (simple_propfind_with_redirect(sess, session, path, NE_DEPTH_ZERO, NULL, listxattr_propfind_callback, &l) != NE_OK) {
+        fprintf(stderr, "dav_listxattr: PROPFIND failed: %s\n", ne_get_error(session));
         return -EIO;
     }
 
@@ -944,7 +1076,8 @@
     return 0;
 }
 
-static int dav_getxattr(
+int dav_getxattr(
+        struct session_info *sess,
         const char *path,
         const char *name,
         char *value,
@@ -957,10 +1090,10 @@
         
     assert(path);
 
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
     name = fix_xattr(name);
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "getxattr(%s, %s, .., %lu)\n", path, name, (unsigned long) size);
 
     if (parse_xattr(name, dnspace, sizeof(dnspace), dname, sizeof(dname)) < 0)
@@ -983,11 +1116,11 @@
 
     g.propname = props[0];
     
-    if (!(session = session_get(1)))
+    if (!(session = session_get(sess, 1)))
         return -EIO;
 
-    if (simple_propfind_with_redirect(session, path, NE_DEPTH_ZERO, props, getxattr_propfind_callback, &g) != NE_OK) {
-        fprintf(stderr, "PROPFIND failed: %s\n", ne_get_error(session));
+    if (simple_propfind_with_redirect(sess, session, path, NE_DEPTH_ZERO, props, getxattr_propfind_callback, &g) != NE_OK) {
+        fprintf(stderr, "dav_getxattr: PROPFIND failed: %s\n", ne_get_error(session));
         return -EIO;
     }
 
@@ -997,7 +1130,8 @@
     return g.size;
 }
 
-static int dav_setxattr(
+int dav_setxattr(
+        struct session_info *sess,
         const char *path,
         const char *name,
         const char *value,
@@ -1015,10 +1149,10 @@
     assert(name);
     assert(value);
 
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
     name = fix_xattr(name);
     
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "setxattr(%s, %s)\n", path, name);
 
     if (flags) {
@@ -1051,18 +1185,18 @@
     
     ops[1].name = NULL;
 
-    if (!(session = session_get(1))) {
+    if (!(session = session_get(sess, 1))) {
         r = -EIO;
         goto finish;
     }
                  
-    if (proppatch_with_redirect(session, path, ops)) {
+    if (proppatch_with_redirect(sess, session, path, ops)) {
         fprintf(stderr, "PROPPATCH failed: %s\n", ne_get_error(session));
         r = -ENOTSUP;
         goto finish;
     }
     
-    stat_cache_invalidate(path);
+    stat_cache_invalidate(sess, path);
 
 finish:
     free(value_fixed);
@@ -1070,7 +1204,7 @@
     return r;
 }
 
-static int dav_removexattr(const char *path, const char *name) {
+int dav_removexattr(struct session_info *sess, const char *path, const char *name) {
     ne_session *session;
     ne_propname propname;
     ne_proppatch_operation ops[2];
@@ -1080,10 +1214,10 @@
     assert(path);
     assert(name);
 
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
     name = fix_xattr(name);
     
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "removexattr(%s, %s)\n", path, name);
 
     if (parse_xattr(name, dnspace, sizeof(dnspace), dname, sizeof(dname)) < 0) {
@@ -1100,25 +1234,25 @@
     
     ops[1].name = NULL;
 
-    if (!(session = session_get(1))) {
+    if (!(session = session_get(sess, 1))) {
         r = -EIO;
         goto finish;
     }
                  
-    if (proppatch_with_redirect(session, path, ops)) {
+    if (proppatch_with_redirect(sess, session, path, ops)) {
         fprintf(stderr, "PROPPATCH failed: %s\n", ne_get_error(session));
         r = -ENOTSUP;
         goto finish;
     }
     
-    stat_cache_invalidate(path);
+    stat_cache_invalidate(sess, path);
 
 finish:
     
     return r;
 }
 
-static int dav_chmod(const char *path, mode_t mode) {
+int dav_chmod(struct session_info *sess, const char *path, mode_t mode) {
     ne_session *session;
     const ne_propname executable = { "http://apache.org/dav/props/", "executable" };
     ne_proppatch_operation ops[2];
@@ -1126,9 +1260,9 @@
     
     assert(path);
 
-    path = path_cvt(path);
+    path = path_cvt(path, sess);
     
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "chmod(%s, %04o)\n", path, mode);
     
     ops[0].name = &executable;
@@ -1136,25 +1270,25 @@
     ops[0].value = mode & 0111 ? "T" : "F";
     ops[1].name = NULL;
 
-    if (!(session = session_get(1))) {
+    if (!(session = session_get(sess, 1))) {
         r = -EIO;
         goto finish;
     }
 
-    if (proppatch_with_redirect(session, path, ops)) {
+    if (proppatch_with_redirect(sess, session, path, ops)) {
         fprintf(stderr, "PROPPATCH failed: %s\n", ne_get_error(session));
         r = -ENOTSUP;
         goto finish;
     }
     
-    stat_cache_invalidate(path);
+    stat_cache_invalidate(sess, path);
 
 finish:
     
     return r;
 }
 
-static struct fuse_operations dav_oper = {
+/*static struct fuse_operations dav_oper = {
     .getattr	 = dav_getattr,
     .readdir	 = dav_readdir,
     .mknod	 = dav_mknod,
@@ -1174,7 +1308,7 @@
     .getxattr    = dav_getxattr,
     .listxattr   = dav_listxattr,
     .removexattr = dav_removexattr,
-};
+};*/
 
 static void usage(char *argv0) {
     char *e;
@@ -1193,14 +1327,14 @@
             "\t-o Additional FUSE mount options\n"
             "\t-L Locking the repository during mount\n"
             "\t-t Set lock timeout\n"
-            "\t-n No cache (default is file cache)\n",
+            "\t-n No file cache on disk (do not cache file data on disk, default is file cache on disk)\n",
             e);
 }
 
 static void exit_handler(__unused int sig) {
     static const char m[] = "*** Caught signal ***\n";
-    if(fuse != NULL)
-        fuse_exit(fuse);
+    /*if(fuse != NULL)
+        fuse_exit(fuse);*/
     write(2, m, strlen(m));
 }
 
@@ -1249,7 +1383,7 @@
     return 0;
 }
 
-static int create_lock(void) {
+static int create_lock(struct session_info *sess) {
     ne_session *session;
     char _owner[64], *owner;
     int i;
@@ -1258,10 +1392,10 @@
     lock = ne_lock_create();
     assert(lock);
 
-    if (!(session = session_get(0)))
+    if (!(session = session_get(sess, 0)))
         return -1;
 
-    if (!(owner = username))
+    if (!(owner = sess->username))
         if (!(owner = getenv("USER")))
             if (!(owner = getenv("LOGNAME"))) {
                 snprintf(_owner, sizeof(_owner), "%lu", (unsigned long) getuid());
@@ -1270,12 +1404,12 @@
 
     ne_fill_server_uri(session, &lock->uri);
     
-    lock->uri.path = strdup(base_directory);
+    lock->uri.path = strdup(sess->base_directory);
     lock->depth = NE_DEPTH_INFINITE;
     lock->timeout = lock_timeout;
     lock->owner = strdup(owner);
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "Acquiring lock...\n");
     
     for (i = 0; i < MAX_REDIRECTS; i++) {
@@ -1287,10 +1421,10 @@
         if (!(u = ne_redirect_location(session)))
             break;
 
-        if (!session_is_local(u))
+        if (!session_is_local(sess, u))
             break;
 
-        if (debug)
+        if (dav_debug)
             fprintf(stderr, "REDIRECT FROM '%s' to '%s'\n", lock->uri.path, u->path);
 
         free(lock->uri.path);
@@ -1312,15 +1446,15 @@
     return 0;
 }
 
-static int remove_lock(void) {
+static int remove_lock(struct session_info *sess) {
     ne_session *session;
 
     assert(lock);
 
-    if (!(session = session_get(0)))
+    if (!(session = session_get(sess, 0)))
         return -1;
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "Removing lock...\n");
 
     if (ne_unlock(session, lock)) {
@@ -1331,14 +1465,15 @@
     return 0;
 }
 
-static void *lock_thread_func(__unused void *p) {
+static void *lock_thread_func(void *p) {
     ne_session *session;
     sigset_t block;
+    struct session_info *sess = (struct session_info *)p;
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "lock_thread entering\n");
 
-    if (!(session = session_get(1)))
+    if (!(session = session_get(sess, 1)))
         return NULL;
 
     sigemptyset(&block);
@@ -1369,25 +1504,26 @@
         sleep(t);
     }
     
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "lock_thread exiting\n");
 
     return NULL;
 }
 
-int main(int argc, char *argv[]) {
+struct session_info *dav_init(int argc, char *argv[]) {
     int c;
     char *u = NULL, *p = NULL, *o = NULL;
-    int fuse_fd = -1;
-    int ret = 1;
-    char mountpoint[PATH_MAX];
-    pthread_t lock_thread;
-    int lock_thread_running = 0;
+    //int fuse_fd = -1;
+    //int ret = 1;
+    struct session_info *sess = NULL;
+    //char mountpoint[PATH_MAX];
+    /*pthread_t lock_thread;
+    int lock_thread_running = 0;*/
     int enable_locking = 0;
     
-    static char *mount_args_strings[] = {
-        NULL,  /* path*/
-        NULL,  /* -o */
+    /*static char *mount_args_strings[] = {
+        NULL,  // path
+        NULL,  // -o
         NULL,
         NULL};
     
@@ -1395,7 +1531,7 @@
         .argc = 1,
         .argv = mount_args_strings,
         .allocated = 0
-    };
+    };*/
     
     if (ne_sock_init()) {
         fprintf(stderr, "Failed to initialize libneon.\n");
@@ -1412,11 +1548,16 @@
     mask = umask(0);
     umask(mask);
 
-    cache_alloc();
+    sess = session_create();
+    if (sess == NULL)
+        goto finish;
+
+    cache_alloc(sess);
 
     if (setup_signal_handlers() < 0)
         goto finish;
-    
+
+    optind = 1;
     while ((c = getopt(argc, argv, "hu:p:Do:Lt:n")) != -1) {
 
         switch(c) {
@@ -1429,7 +1570,7 @@
                 break;
                 
             case 'D':
-                debug = !debug;
+                dav_debug = !dav_debug;
                 break;
 
             case 'o':
@@ -1452,7 +1593,7 @@
                 break;
 
             case 'h':
-                ret = 0;
+                sess = NULL;
 
                 /* fall through */
             default:
@@ -1461,20 +1602,21 @@
         }
     }
 
-    /*if (debug)
-        ne_debug_init(stderr, 2);*/
-
     if (optind != argc-2) {
         usage(argv[0]);
         goto finish;
     }
 
-    if (session_set_uri(argv[optind], u, p) < 0) {
+    if (dav_debug)
+        ne_debug_init(stderr, 2);
+
+    if (session_set_uri(sess, argv[optind], u, p) < 0) {
+        sess = NULL;
         usage(argv[0]);
         goto finish;
     }
 
-    if (argv[optind+1][0] == '/')
+    /*if (argv[optind+1][0] == '/')
         snprintf(mountpoint, sizeof(mountpoint), "%s", argv[optind+1]);
     else {
         char *pwd = get_current_dir_name();
@@ -1498,44 +1640,50 @@
     if (!(fuse = fuse_new(fuse_fd, &mount_args, &dav_oper, sizeof(dav_oper)))) {
         fprintf(stderr, "Failed to create FUSE object.\n");
         goto finish;
-    }
+    }*/
     
-    if (enable_locking && create_lock() >= 0) {
+    if (enable_locking && create_lock(sess) >= 0) {
         int r;
-        if ((r = pthread_create(&lock_thread, NULL, lock_thread_func, NULL)) < 0) {
+        if ((r = pthread_create(&sess->lock_thread, NULL, lock_thread_func, sess)) < 0) {
             fprintf(stderr, "pthread_create(): %s\n", strerror(r));
             goto finish;
         }
         
-        lock_thread_running = 1;
+        sess->lock_thread_running = 1;
     }
     
-    fuse_loop_mt(fuse);
+    /*fuse_loop_mt(fuse);
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "Exiting cleanly.\n");
     
-    ret = 0;
-    
+    ret = 0;*/
+
+    return sess;
+
 finish:
-    
-    if (lock_thread_running) {
+    sess = NULL;
+    return sess;
+}
+
+void dav_destroy(struct session_info *sess) {
+    if (sess->lock_thread_running) {
         lock_thread_exit = 1;
-        pthread_kill(lock_thread, SIGUSR1);
-        pthread_join(lock_thread, NULL);
-        remove_lock();
+        pthread_kill(sess->lock_thread, SIGUSR1);
+        pthread_join(sess->lock_thread, NULL);
+        remove_lock(sess);
         ne_lockstore_destroy(lock_store);
     }
 
-    if (fuse)
+    /*if (fuse)
         fuse_destroy(fuse);
     
     if (fuse_fd >= 0)
-        fuse_unmount(mountpoint);
+        fuse_unmount(mountpoint);*/
     
-    file_cache_close_all();
-    cache_free();
-    session_free();
-    
-    return ret;
+    file_cache_close_all(sess);
+    cache_free(sess);
+    session_free(sess);
+    free(sess);
 }
+
diff -urN fusedav.orig/src/fusedav.h fusedav.new/src/fusedav.h
--- fusedav.orig/src/fusedav.h	2010-05-05 13:57:10.000000000 +0200
+++ fusedav.new/src/fusedav.h	2011-03-21 16:45:13.000000000 +0100
@@ -21,7 +21,11 @@
   Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 ***/
 
-extern int debug;
+#include <fuse.h>
+
+#include "session.h"
+
+extern int dav_debug;
 
 #ifdef __GNUC__
 #define __unused __attribute__ ((unused))
@@ -29,4 +33,47 @@
 #define __unused
 #endif
 
+int dav_readdir(
+        struct session_info *sess,
+        const char *path,
+        void *buf,
+        fuse_fill_dir_t filler,
+        __unused off_t offset,
+        __unused struct fuse_file_info *fi);
+int dav_getattr(struct session_info *sess, const char *path, struct stat *stbuf);
+int dav_unlink(struct session_info *sess, const char *path);
+int dav_rmdir(struct session_info *sess, const char *path);
+int dav_mkdir(struct session_info *sess, const char *path, __unused mode_t mode);
+int dav_rename(struct session_info *sess, const char *from, const char *to);
+int dav_release(struct session_info *sess, const char *path, __unused struct fuse_file_info *info);
+int dav_fsync(struct session_info *sess, const char *path, __unused int isdatasync, __unused struct fuse_file_info *info);
+int dav_mknod(struct session_info *sess, const char *path, mode_t mode, __unused dev_t rdev);
+int dav_open(struct session_info *sess, const char *path, struct fuse_file_info *info);
+int dav_read(struct session_info *sess, const char *path, char *buf, size_t size, off_t offset, __unused struct fuse_file_info *info);
+int dav_write(struct session_info *sess, const char *path, const char *buf, size_t size, off_t offset, __unused struct fuse_file_info *info);
+int dav_truncate(struct session_info *sess, const char *path, off_t size);
+int dav_utime(struct session_info *sess, const char *path, struct utimbuf *buf);
+int dav_listxattr(
+        struct session_info *sess,
+        const char *path,
+        char *list,
+        size_t size);
+int dav_getxattr(
+        struct session_info *sess,
+        const char *path,
+        const char *name,
+        char *value,
+        size_t size);
+int dav_setxattr(
+        struct session_info *sess,
+        const char *path,
+        const char *name,
+        const char *value,
+        size_t size,
+        int flags);
+int dav_removexattr(struct session_info *sess, const char *path, const char *name);
+int dav_chmod(struct session_info *sess, const char *path, mode_t mode);
+struct session_info *dav_init(int argc, char *argv[]);
+void dav_destroy(struct session_info *sess);
+
 #endif
diff -urN fusedav.orig/src/Makefile.am fusedav.new/src/Makefile.am
--- fusedav.orig/src/Makefile.am	2011-03-21 16:41:58.000000000 +0100
+++ fusedav.new/src/Makefile.am	2011-03-21 16:43:19.000000000 +0100
@@ -16,13 +16,13 @@
 # along with fusedav; if not, write to the Free Software Foundation,
 # Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 
-bin_PROGRAMS=fusedav
+noinst_LIBRARIES = libfusedav.a
 
-fusedav_SOURCES=fusedav.c fusedav.h \
+libfusedav_a_SOURCES=fusedav.c fusedav.h \
 				statcache.c statcache.h \
 				filecache.c filecache.h \
 				remoteaccess.c remoteaccess.h \
 				session.c session.h
 
-fusedav_CFLAGS = $(AM_CFLAGS) $(NEON_CFLAGS) $(FUSE_CFLAGS) -DFUSE_USE_VERSION=25
-fusedav_LDADD = -lpthread $(NEON_LIBS) $(FUSE_LIBS)
+libfusedav_a_CFLAGS = $(AM_CFLAGS) $(NEON_CFLAGS) $(FUSE_CFLAGS) -DFUSE_USE_VERSION=25
+#libfusedav_a_LDADD = -lpthread $(NEON_LIBS) $(FUSE_LIBS)
diff -urN fusedav.orig/src/remoteaccess.c fusedav.new/src/remoteaccess.c
--- fusedav.orig/src/remoteaccess.c	2011-03-21 16:41:58.000000000 +0100
+++ fusedav.new/src/remoteaccess.c	2011-03-21 16:45:22.000000000 +0100
@@ -68,7 +68,7 @@
 
 extern int no_cache;
 
-int remote_access_read(void *f, char *buf, size_t size, off_t offset) {
+int remote_access_read(struct session_info *sess, void *f, char *buf, size_t size, off_t offset) {
     struct file_info *fi = f;
     ssize_t r = -1;
     off_t l;
@@ -76,13 +76,13 @@
     ne_session *session;
     ne_generic_data data;
     
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "Called remote_access_read (size=%d, offset=%lld)\n", size, offset);
     assert(fi && buf && size);
 
     pthread_mutex_lock(&fi->mutex);
 
-    if (!(session = session_get(1))) {
+    if (!(session = session_get(sess, 1))) {
         errno = EIO;
         goto finish;
     }
@@ -113,7 +113,7 @@
     return r;
 }
 
-int remote_access_write(void *f, const char *buf, size_t size, off_t offset) {
+int remote_access_write(struct session_info *sess, void *f, const char *buf, size_t size, off_t offset) {
     struct file_info *fi = f;
     ssize_t r = -1;
     off_t l;
@@ -121,13 +121,13 @@
     ne_session *session;
     ne_generic_data data;
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "Called remote_access_write (size=%d, offset=%lld)\n", size, offset);
     assert (fi);
 
     pthread_mutex_lock(&fi->mutex);
 
-    if (!(session = session_get(1))) {
+    if (!(session = session_get(sess, 1))) {
         errno = EIO;
         goto finish;
     }
@@ -143,7 +143,7 @@
     data.generic_data.buf.length = size;
 
     if (ne_put_range_generic(session, fi->filename, &range, &data) != NE_OK) {
-        fprintf(stderr, "PUT failed: %s\n", ne_get_error(session));
+        fprintf(stderr, "remote_access_write: PUT failed: %s\n", ne_get_error(session));
         errno = ENOENT;
         goto finish;
     }
diff -urN fusedav.orig/src/remoteaccess.h fusedav.new/src/remoteaccess.h
--- fusedav.orig/src/remoteaccess.h	2011-03-21 16:41:58.000000000 +0100
+++ fusedav.new/src/remoteaccess.h	2011-03-21 16:43:19.000000000 +0100
@@ -25,7 +25,7 @@
 
 #include <ne_session.h>
 
-int remote_access_read(void *f, char *buf, size_t size, off_t offset);
-int remote_access_write(void *f, const char *buf, size_t size, off_t offset);
+int remote_access_read(struct session_info *sess, void *f, char *buf, size_t size, off_t offset);
+int remote_access_write(struct session_info *sess, void *f, const char *buf, size_t size, off_t offset);
 
 #endif
diff -urN fusedav.orig/src/session.c fusedav.new/src/session.c
--- fusedav.orig/src/session.c	2010-05-05 13:57:10.000000000 +0200
+++ fusedav.new/src/session.c	2011-03-21 16:43:19.000000000 +0100
@@ -43,6 +43,9 @@
 #include "session.h"
 #include "fusedav.h"
 
+static pthread_key_t *session_tsd_key = NULL;
+static pthread_mutex_t session_tsd_key_mutex = PTHREAD_MUTEX_INITIALIZER;
+/*
 static pthread_once_t session_once = PTHREAD_ONCE_INIT;
 static pthread_key_t session_tsd_key;
 
@@ -54,7 +57,7 @@
 char *base_directory = NULL;
 
 static pthread_mutex_t credential_mutex = PTHREAD_MUTEX_INITIALIZER;
-
+*/
 static char* ask_user(const char *p, int hidden) {
     char q[256], *r;
     struct termios t;
@@ -94,10 +97,16 @@
     return 0;
 }
 
-static int ne_auth_creds_cb(__unused void *userdata, const char *realm, int attempt, char *u, char *p) {
+static int ne_auth_creds_cb(void *userdata, const char *realm, int attempt, char *u, char *p) {
     int r = -1;
+    struct session_info *sess = (struct session_info *)userdata;
+    pthread_mutex_t *credential_mutex = &sess->credential_mutex;
+    char *username = sess->username;
+    char *password = sess->password;
+    
+    
     
-    pthread_mutex_lock(&credential_mutex);
+    pthread_mutex_lock(credential_mutex);
 
     if (attempt) {
         fprintf(stderr, "Authentication failure!\n");
@@ -121,28 +130,30 @@
         r  = 0;
     }
 
-    pthread_mutex_unlock(&credential_mutex);
+    pthread_mutex_unlock(credential_mutex);
     return r;
 }
 
-static ne_session *session_open(int with_lock) {
+static ne_session *session_open(struct session_info *sess, int with_lock) {
     const char *scheme = NULL;
     ne_session *session;
+    ne_uri *uri = &sess->uri;
+    int b_uri = sess->b_uri;
 
     extern ne_lock_store *lock_store;
 
     if (!b_uri)
         return NULL;
 
-    scheme = uri.scheme ? uri.scheme : "http";
+    scheme = uri->scheme ? uri->scheme : "http";
     
-    if (!(session = ne_session_create(scheme, uri.host, uri.port ? uri.port : ne_uri_defaultport(scheme)))) {
+    if (!(session = ne_session_create(scheme, uri->host, uri->port ? uri->port : ne_uri_defaultport(scheme)))) {
         fprintf(stderr, "Failed to create session\n");
         return NULL;
     }
 
     ne_ssl_set_verify(session, ssl_verify_cb, NULL);
-    ne_set_server_auth(session, ne_auth_creds_cb, NULL);
+    ne_set_server_auth(session, ne_auth_creds_cb, sess);
     ne_redirect_register(session);
 
     if (with_lock && lock_store)
@@ -158,86 +169,110 @@
 }
 
 static void session_tsd_key_init(void) {
-    pthread_key_create(&session_tsd_key, session_destroy);
+    pthread_key_create(session_tsd_key, session_destroy);
 }
 
-ne_session *session_get(int with_lock) {
+ne_session *session_get(struct session_info *sess, int with_lock) {
     ne_session *session;
     
-    pthread_once(&session_once, session_tsd_key_init);
+    pthread_mutex_lock(&session_tsd_key_mutex);
+    session_tsd_key = &sess->session_tsd_key;
+    pthread_once(&sess->session_once, session_tsd_key_init);
+    session_tsd_key = NULL;
+    pthread_mutex_unlock(&session_tsd_key_mutex);
 
-    if ((session = pthread_getspecific(session_tsd_key)))
+    if ((session = pthread_getspecific(sess->session_tsd_key)))
         return session;
 
-    session = session_open(with_lock);
-    pthread_setspecific(session_tsd_key, session);
+    session = session_open(sess, with_lock);
+    pthread_setspecific(sess->session_tsd_key, session);
 
     return session;
 }
 
-int session_set_uri(const char *s, const char *u, const char *p) {
+int session_set_uri(struct session_info *sess, const char *s, const char *u, const char *p) {
     int l;
         
-    assert(!b_uri);
-    assert(!username);
-    assert(!password);
+    assert(!sess->b_uri);
+    assert(!sess->username);
+    assert(!sess->password);
 
-    if (ne_uri_parse(s, &uri)) {
+    if (ne_uri_parse(s, &sess->uri)) {
         fprintf(stderr, "Invalid URI <%s>\n", s);
         goto finish;
     }
 
-    b_uri = 1;
+    sess->b_uri = 1;
 
-    if (!uri.host) {
+    if (!sess->uri.host) {
         fprintf(stderr, "Missing host part in URI <%s>\n", s);
         goto finish;
     }
 
-    base_directory = strdup(uri.path);
-    l = strlen(base_directory);
-    if (base_directory[l-1] == '/')
-        ((char*) base_directory)[l-1] = 0;
+    sess->base_directory = strdup(sess->uri.path);
+    l = strlen(sess->base_directory);
+    if (sess->base_directory[l-1] == '/')
+        ((char*) sess->base_directory)[l-1] = 0;
 
     if (u)
-        username = strdup(u);
+        sess->username = strdup(u);
 
     if (p)
-        password = strdup(p);
+        sess->password = strdup(p);
 
     return 0;
     
 finish:
     
-    if (b_uri) {
-        ne_uri_free(&uri);
-        b_uri = 0;
+    if (sess->b_uri) {
+        ne_uri_free(&sess->uri);
+        sess->b_uri = 0;
     }
 
     return -1;
 }
 
+struct session_info *session_create(void) {
+    struct session_info *sess = NULL;
+    pthread_once_t tmp_once = PTHREAD_ONCE_INIT;
+    pthread_mutex_t tmp_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+    sess = malloc (sizeof(struct session_info));
+    memset (sess, 0, sizeof(struct session_info));
+
+    memcpy(&sess->session_once, &tmp_once, sizeof(pthread_once_t));
+    memcpy(&sess->credential_mutex, &tmp_mutex, sizeof(pthread_mutex_t));
 
-void session_free(void) {
-    if (b_uri) {
-        ne_uri_free(&uri);
-        b_uri = 0;
+    memcpy(&sess->files_mutex, &tmp_mutex, sizeof(pthread_mutex_t));
+
+    memcpy(&sess->stat_cache_mutex, &tmp_mutex, sizeof(pthread_mutex_t));
+    memcpy(&sess->dir_cache_mutex, &tmp_mutex, sizeof(pthread_mutex_t));
+
+    return sess;
+}
+
+void session_free(struct session_info *sess) {
+    if (sess->b_uri) {
+        ne_uri_free(&sess->uri);
+        sess->b_uri = 0;
     }
 
-    free((char*) username);
-    free((char*) password);
-    free((char*) base_directory);
+    free((char*) sess->username);
+    free((char*) sess->password);
+    free((char*) sess->base_directory);
+
+    sess->username = sess->password = sess->base_directory = NULL;
 
-    username = password = base_directory = NULL;
+    free(sess);
 }
 
-int session_is_local(const ne_uri *u) {
+int session_is_local(struct session_info *sess, const ne_uri *u) {
     assert(u);
-    assert(b_uri);
+    assert(sess->b_uri);
 
     return
-        strcmp(u->scheme, uri.scheme) == 0 &&
-        strcmp(u->host, uri.host) == 0 &&
-        u->port == uri.port;
+        strcmp(u->scheme, sess->uri.scheme) == 0 &&
+        strcmp(u->host, sess->uri.host) == 0 &&
+        u->port == sess->uri.port;
 }
 
diff -urN fusedav.orig/src/session.h fusedav.new/src/session.h
--- fusedav.orig/src/session.h	2010-05-05 13:57:10.000000000 +0200
+++ fusedav.new/src/session.h	2011-03-21 16:43:19.000000000 +0100
@@ -24,14 +24,41 @@
 #include <ne_session.h>
 #include <ne_locks.h>
 
-ne_session *session_get(int with_lock);
-int session_set_uri(const char *s, const char*u, const char*p);
-void session_free(void);
+struct session_info {
+    pthread_t lock_thread;
+    int lock_thread_running;// = 0;
 
-int session_is_local(const ne_uri *u);
+    pthread_once_t session_once;// = PTHREAD_ONCE_INIT;
+    pthread_key_t session_tsd_key;
 
-extern char *base_directory;
+    ne_uri uri;
+    int b_uri;// = 0;
+
+    char *username;// = NULL;
+    char *password;// = NULL;
+    char *base_directory;// = NULL;
+
+    pthread_mutex_t credential_mutex;// = PTHREAD_MUTEX_INITIALIZER;
+
+    struct file_info *files;// = NULL;
+    pthread_mutex_t files_mutex;// = PTHREAD_MUTEX_INITIALIZER;
+
+    struct cache_entry *cache;// = NULL;
+    pthread_mutex_t stat_cache_mutex;// = PTHREAD_MUTEX_INITIALIZER;
+    pthread_mutex_t dir_cache_mutex;// = PTHREAD_MUTEX_INITIALIZER;
+};
+
+#include "statcache.h"
+
+ne_session *session_get(struct session_info *sess, int with_lock);
+int session_set_uri(struct session_info *sess, const char *s, const char *u, const char *p);
+struct session_info *session_create(void);
+void session_free(struct session_info *sess);
+
+int session_is_local(struct session_info *sess, const ne_uri *u);
+
+/*extern char *base_directory;
 extern ne_uri uri;
-extern char *username;
+extern char *username;*/
 
 #endif
diff -urN fusedav.orig/src/statcache.c fusedav.new/src/statcache.c
--- fusedav.orig/src/statcache.c	2010-05-05 13:57:10.000000000 +0200
+++ fusedav.new/src/statcache.c	2011-03-21 16:45:27.000000000 +0100
@@ -62,9 +62,11 @@
     } dir_info;
 };
 
+/*
 static struct cache_entry *cache = NULL;
 static pthread_mutex_t stat_cache_mutex = PTHREAD_MUTEX_INITIALIZER;
 static pthread_mutex_t dir_cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+*/
 
 static uint32_t calc_hash(const char *s) {
     uint32_t h = 0;
@@ -77,21 +79,21 @@
     return h;
 }
 
-int stat_cache_get(const char *fn, struct stat *st) {
+int stat_cache_get(struct session_info *sess, const char *fn, struct stat *st) {
     uint32_t h;
     struct cache_entry *ce;
     int r = -1;
     void *f;
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "CGET: %s\n", fn);
     
-    assert(cache);
+    assert(sess->cache);
     
     h = calc_hash(fn);
-    ce = cache + (h % CACHE_SIZE);
+    ce = sess->cache + (h % CACHE_SIZE);
 
-    pthread_mutex_lock(&stat_cache_mutex);
+    pthread_mutex_lock(&sess->stat_cache_mutex);
     
     if (ce->stat_info.valid &&
         ce->stat_info.filename &&
@@ -101,31 +103,31 @@
         
         *st = ce->stat_info.st;
 
-        if ((f = file_cache_get(fn))) {
+        if ((f = file_cache_get(sess, fn))) {
             st->st_size = file_cache_get_size(f);
-            file_cache_unref(f);
+            file_cache_unref(sess, f);
         }
 
         r = 0;
     }
 
-    pthread_mutex_unlock(&stat_cache_mutex);
+    pthread_mutex_unlock(&sess->stat_cache_mutex);
     
     return r;
 }
 
-void stat_cache_set(const char *fn, const struct stat*st) {
+void stat_cache_set(struct session_info *sess, const char *fn, const struct stat*st) {
     uint32_t h;
     struct cache_entry *ce;
 
-    if (debug)
+    if (dav_debug)
         fprintf(stderr, "CSET: %s\n", fn);
-    assert(cache);
+    assert(sess->cache);
     
     h = calc_hash(fn);
-    ce = cache + (h % CACHE_SIZE);
+    ce = sess->cache + (h % CACHE_SIZE);
 
-    pthread_mutex_lock(&stat_cache_mutex);
+    pthread_mutex_lock(&sess->stat_cache_mutex);
 
     if (!ce->stat_info.filename || ce->stat_info.hash != h || strcmp(ce->stat_info.filename, fn)) {
         free(ce->stat_info.filename);
@@ -137,25 +139,25 @@
     ce->stat_info.dead = time(NULL)+CACHE_TIMEOUT;
     ce->stat_info.valid = 1;
 
-    pthread_mutex_unlock(&stat_cache_mutex);
+    pthread_mutex_unlock(&sess->stat_cache_mutex);
 }
 
-void stat_cache_invalidate(const char*fn) {
+void stat_cache_invalidate(struct session_info *sess, const char*fn) {
     uint32_t h;
     struct cache_entry *ce;
 
-    assert(cache);
+    assert(sess->cache);
     
     h = calc_hash(fn);
-    ce = cache + (h % CACHE_SIZE);
+    ce = sess->cache + (h % CACHE_SIZE);
 
-    pthread_mutex_lock(&stat_cache_mutex);
+    pthread_mutex_lock(&sess->stat_cache_mutex);
 
     ce->stat_info.valid = 0;
     free(ce->stat_info.filename);
     ce->stat_info.filename = NULL;
     
-    pthread_mutex_unlock(&stat_cache_mutex);
+    pthread_mutex_unlock(&sess->stat_cache_mutex);
 }
 
 static void free_dir_entries(struct dir_entry *de) {
@@ -168,16 +170,16 @@
 }
 
 
-void dir_cache_begin(const char *fn) {
+void dir_cache_begin(struct session_info *sess, const char *fn) {
     uint32_t h;
     struct cache_entry *ce;
     struct dir_entry *de = NULL, *de2 = NULL;
-    assert(cache);
+    assert(sess->cache);
     
     h = calc_hash(fn);
-    ce = cache + (h % CACHE_SIZE);
+    ce = sess->cache + (h % CACHE_SIZE);
     
-    pthread_mutex_lock(&dir_cache_mutex);
+    pthread_mutex_lock(&sess->dir_cache_mutex);
 
     if (!ce->dir_info.filling) {
         
@@ -197,21 +199,21 @@
         ce->dir_info.filling = 1;
     }
     
-    pthread_mutex_unlock(&dir_cache_mutex);
+    pthread_mutex_unlock(&sess->dir_cache_mutex);
     free_dir_entries(de);
     free_dir_entries(de2);
 }
 
-void dir_cache_finish(const char *fn, int success) {
+void dir_cache_finish(struct session_info *sess, const char *fn, int success) {
     uint32_t h;
     struct cache_entry *ce;
     struct dir_entry *de = NULL;
-    assert(cache);
+    assert(sess->cache);
     
     h = calc_hash(fn);
-    ce = cache + (h % CACHE_SIZE);
+    ce = sess->cache + (h % CACHE_SIZE);
     
-    pthread_mutex_lock(&dir_cache_mutex);
+    pthread_mutex_lock(&sess->dir_cache_mutex);
     
     if (ce->dir_info.filling &&
         ce->dir_info.filename &&
@@ -242,19 +244,19 @@
         }
     }
 
-    pthread_mutex_unlock(&dir_cache_mutex);
+    pthread_mutex_unlock(&sess->dir_cache_mutex);
     free_dir_entries(de);
 }
 
-void dir_cache_add(const char *fn, const char *subdir) {
+void dir_cache_add(struct session_info *sess, const char *fn, const char *subdir) {
     uint32_t h;
     struct cache_entry *ce;
-    assert(cache);
+    assert(sess->cache);
     
     h = calc_hash(fn);
-    ce = cache + (h % CACHE_SIZE);
+    ce = sess->cache + (h % CACHE_SIZE);
     
-    pthread_mutex_lock(&dir_cache_mutex);
+    pthread_mutex_lock(&sess->dir_cache_mutex);
     
     if (ce->dir_info.filling &&
         ce->dir_info.filename &&
@@ -274,21 +276,21 @@
         ce->dir_info.entries2 = n;
     }
 
-    pthread_mutex_unlock(&dir_cache_mutex);
+    pthread_mutex_unlock(&sess->dir_cache_mutex);
 }
 
-int dir_cache_enumerate(const char *fn, void (*f) (const char*fn, const char *subdir, void *user), void *user) {
+int dir_cache_enumerate(struct session_info *sess, const char *fn, void (*f) (const char*fn, const char *subdir, void *user), void *user) {
     uint32_t h;
     struct cache_entry *ce;
     struct dir_entry *de = NULL;
     int r = -1;
 
-    assert(cache && f);
+    assert(sess->cache && f);
     
     h = calc_hash(fn);
-    ce = cache + (h % CACHE_SIZE);
+    ce = sess->cache + (h % CACHE_SIZE);
     
-    pthread_mutex_lock(&dir_cache_mutex);
+    pthread_mutex_lock(&sess->dir_cache_mutex);
     
     if (ce->dir_info.valid &&
         ce->dir_info.filename &&
@@ -297,12 +299,12 @@
         time(NULL) <= ce->dir_info.dead) {
 
         ce->dir_info.in_use = 1;
-        pthread_mutex_unlock(&dir_cache_mutex);
+        pthread_mutex_unlock(&sess->dir_cache_mutex);
 
         for (de = ce->dir_info.entries; de; de = de->next)
             f(fn, de->filename, user);
 
-        pthread_mutex_lock(&dir_cache_mutex);
+        pthread_mutex_lock(&sess->dir_cache_mutex);
         ce->dir_info.in_use = 0;
 
         if (ce->dir_info.valid2) {
@@ -317,21 +319,21 @@
         r = 0;
     }
     
-    pthread_mutex_unlock(&dir_cache_mutex);
+    pthread_mutex_unlock(&sess->dir_cache_mutex);
     free_dir_entries(de);
 
     return r;
 }   
 
-void dir_cache_invalidate(const char*fn) {
+void dir_cache_invalidate(struct session_info *sess, const char*fn) {
     uint32_t h;
     struct cache_entry *ce;
     struct dir_entry *de = NULL;
-    assert(cache && fn);
+    assert(sess->cache && fn);
     
     h = calc_hash(fn);
-    ce = cache + (h % CACHE_SIZE);
-    pthread_mutex_lock(&dir_cache_mutex);
+    ce = sess->cache + (h % CACHE_SIZE);
+    pthread_mutex_lock(&sess->dir_cache_mutex);
     
     if (ce->dir_info.valid &&
         ce->dir_info.filename &&
@@ -343,11 +345,11 @@
         ce->dir_info.entries = NULL;
     }
     
-    pthread_mutex_unlock(&dir_cache_mutex);
+    pthread_mutex_unlock(&sess->dir_cache_mutex);
     free_dir_entries(de);
 }
 
-void dir_cache_invalidate_parent(const char *fn) {
+void dir_cache_invalidate_parent(struct session_info *sess, const char *fn) {
     char *p;
 
     if ((p = ne_path_parent(fn))) {
@@ -358,36 +360,37 @@
                 p[l-1] = 0;
         }
         
-        dir_cache_invalidate(p);
+        dir_cache_invalidate(sess, p);
         free(p);
     } else
-        dir_cache_invalidate(fn);
+        dir_cache_invalidate(sess, fn);
 }
 
-void cache_free(void) {
+void cache_free(struct session_info *sess) {
     uint32_t h;
     struct cache_entry *ce;
 
-    if (!cache)
+    if (!sess->cache)
         return;
 
-    for (h = 0, ce = cache; h < CACHE_SIZE; h++, ce++) {
+    for (h = 0, ce = sess->cache; h < CACHE_SIZE; h++, ce++) {
         free(ce->stat_info.filename);
         free(ce->dir_info.filename);
         free_dir_entries(ce->dir_info.entries);
         free_dir_entries(ce->dir_info.entries2);
     }
 
-    memset(cache, 0, sizeof(struct cache_entry)*CACHE_SIZE);
+    memset(sess->cache, 0, sizeof(struct cache_entry)*CACHE_SIZE);
+    free(sess->cache);
 }
 
-void cache_alloc(void) {
+void cache_alloc(struct session_info *sess) {
     
-    if (cache)
+    if (sess->cache)
         return;
 
-    cache = malloc(sizeof(struct cache_entry)*CACHE_SIZE);
-    assert(cache);
-    memset(cache, 0, sizeof(struct cache_entry)*CACHE_SIZE);
+    sess->cache = malloc(sizeof(struct cache_entry)*CACHE_SIZE);
+    assert(sess->cache);
+    memset(sess->cache, 0, sizeof(struct cache_entry)*CACHE_SIZE);
 }
 
diff -urN fusedav.orig/src/statcache.h fusedav.new/src/statcache.h
--- fusedav.orig/src/statcache.h	2010-05-05 13:57:10.000000000 +0200
+++ fusedav.new/src/statcache.h	2011-03-21 16:43:19.000000000 +0100
@@ -23,18 +23,20 @@
 
 #include <sys/stat.h>
 
-int stat_cache_get(const char *fn, struct stat *st);
-void stat_cache_set(const char *fn, const struct stat *st);
-void stat_cache_invalidate(const char*fn);
-
-void dir_cache_invalidate(const char*fn);
-void dir_cache_invalidate_parent(const char *fn);
-void dir_cache_begin(const char *fn);
-void dir_cache_finish(const char *fn, int success);
-void dir_cache_add(const char *fn, const char *subdir);
-int dir_cache_enumerate(const char *fn, void (*f) (const char*fn, const char *subdir, void *user), void *user);
+#include "session.h"
 
-void cache_free(void);
-void cache_alloc(void);
+int stat_cache_get(struct session_info *sess, const char *fn, struct stat *st);
+void stat_cache_set(struct session_info *sess, const char *fn, const struct stat *st);
+void stat_cache_invalidate(struct session_info *sess, const char*fn);
+
+void dir_cache_invalidate(struct session_info *sess, const char*fn);
+void dir_cache_invalidate_parent(struct session_info *sess, const char *fn);
+void dir_cache_begin(struct session_info *sess, const char *fn);
+void dir_cache_finish(struct session_info *sess, const char *fn, int success);
+void dir_cache_add(struct session_info *sess, const char *fn, const char *subdir);
+int dir_cache_enumerate(struct session_info *sess, const char *fn, void (*f) (const char*fn, const char *subdir, void *user), void *user);
+
+void cache_free(struct session_info *sess);
+void cache_alloc(struct session_info *sess);
 
 #endif
